#!/usr/bin/env cs
#
# Covariant Script AST Visitor Generator v1.0.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2021 Michael Lee(李登淳)
#
# Email:   lee@covariant.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn

package visitorgen

import parsergen

@begin
var header =
"#!/usr/bin/env cs\n" +
"# Generated by CovScript AST Visitor Generator\n" +
"# Date: " + to_string(runtime.local_time()) +
"import parsergen\n\n" +
"class main\n" +
"\tvar target = system.out\n" +
"\tvar indent_size = 2\n" +
"\tfunction print_indent(indent)\n" +
"\t\tforeach i in range(2*indent_size) do target.print(' ')\n" +
"\tend\n" +
"\tfunction visit(indent, it)\n" +
"\t\tif typeid it != typeid parsergen.syntax_tree\n" +
"\t\t\t# Handle Separated Token\n" +
"\t\t\treturn\n" +
"\t\tend\n" +
"\t\tvar idx = 0\n" +
"\t\tswitch ast.root"
@end

@begin
var tail =
"\t\tend\n\tend\n" +
"\tfunction run(ast)\n" +
"\t\tthis.visit(0, ast)\n" +
"\tend\nend"
@end

class visitor_base

end

class visitor_generator
    var target = system.out
    var syntax = null
    var indent = 2
    function print(text)
        foreach i in range(indent) do target.print('\t')
        target.print(text)
    end
    function println(text)
        foreach i in range(indent) do target.print('\t')
        target.println(text)
    end
    function get_prefix_stx(stx)
        switch stx.type
            case parsergen.syntax_type.nlook
                return null
            end
            case parsergen.syntax_type.token
                return {stx}
            end
            case parsergen.syntax_type.term
                return {stx}
            end
            case parsergen.syntax_type.ref
                return this.get_prefix(stx.data)
            end
        end
    end
    function get_prefix(seq)
        var data = new array
        var it = seq.begin
        loop
            switch it.data.type
                case parsergen.syntax_type.token
                    data.push_back(it.data)
                    break
                end
                case parsergen.syntax_type.term
                    data.push_back(it.data)
                    break
                end
                case parsergen.syntax_type.nlook
                    it.next()
                end
                case parsergen.syntax_type.ref
                    var product = get_prefix(syntax[it.data.data])
                    if product != null
                        foreach stx in product do data.push_back(move(stx))
                    end
                    break
                end
                case parsergen.syntax_type.repeat
                    var product = get_prefix(it.data.data)
                    if product != null
                        foreach stx in product do data.push_back(move(stx))
                    end
                    break
                end
                case parsergen.syntax_type.opt
                    var product = get_prefix(it.data.data)
                    if product != null
                        foreach stx in product do data.push_back(move(stx))
                    end
                    it.next()
                end
                case parsergen.syntax_type.cond
                    foreach stx in it.data.data
                        var product = get_prefix(stx)
                        if product != null
                            foreach stx in product do data.push_back(move(stx))
                        end
                    end
                    break
                end
            end
        end
        if !data.empty()
            return data
        else
            return null
        end
    end
    function gen_match(stx)
        if stx.type == parsergen.syntax_type.term
            target.print("it.nodes.at(itx).data == \"" + stx.data + "\"")
        else
            target.print("it.nodes.at(itx).type == \"" + stx.data + "\"")
        end
    end
    function gen_syntax(s)
        switch s.type
            case parsergen.syntax_type.token
                println("# Visit " + s.data + " token")
                println("target.print(it.nodes.at(idx++))")
            end
            case parsergen.syntax_type.term
                println("# Visit term \"" + s.data + "\"")
                println("++idx; target.print(\"" + s.data + "\")")
            end
            case parsergen.syntax_type.ref
                println("# Recursive Visit " + s.data)
                println("visit(indent, it.nodes.at(idx++))")
            end
            case parsergen.syntax_type.repeat
                println("# Repeat")
                var prefix = get_prefix(s.data)
                var beg = prefix.begin
                print("while ")
                gen_match(beg.data)
                loop
                    beg.next()
                    if beg != prefix.end
                        target.print(" || ")
                        gen_match(beg.data)
                    else
                        break
                    end
                end
                target.println("")
                ++indent
                foreach it in s.data
                    gen_syntax(it)
                end
                --indent
                println("end")
            end
            case parsergen.syntax_type.opt
                println("# Optional")
                var prefix = get_prefix(s.data)
                var beg = prefix.begin
                print("if ")
                gen_match(beg.data)
                loop
                    beg.next()
                    if beg != prefix.end
                        target.print(" || ")
                        gen_match(beg.data)
                    else
                        break
                    end
                end
                target.println("")
                ++indent
                foreach it in s.data
                    gen_syntax(it)
                end
                --indent
                println("end")
            end
            case parsergen.syntax_type.cond
                println("# Condition")
                println("block")
                ++indent
                println("var matched = false")
                foreach seq in s.data
                    var prefix = get_prefix(seq)
                    var beg = prefix.begin
                    print("if !matched && (")
                    gen_match(beg.data)
                    loop
                        beg.next()
                        if beg != prefix.end
                            target.print(" || ")
                            gen_match(beg.data)
                        else
                            break
                        end
                    end
                    target.println(")")
                    ++indent
                    println("matched = true")
                    foreach it in seq
                        gen_syntax(it)
                    end
                    --indent
                    println("end")
                end
                println("if !matched")
                println("\t# Error")
                println("\treturn")
                println("end")
                --indent
                println("end") 
            end
        end
    end
    function run(os, stx)
        target = os
        syntax = stx
        target.println(header)
        foreach it in stx
            println("case \"" + it.first + "\"")
            ++indent
            foreach s in it.second
                gen_syntax(s)
            end
            --indent
            println("end")
        end
        target.println(tail)
    end
end